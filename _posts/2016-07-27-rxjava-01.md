---
layout: post
title: RxJava - Learn from Zero(0x01)
published: true
---

(by [@jpwang](https://github.com/jp-wang) and original post is [here](hhttps://github.com/jp-wang/jp-wang.github.io/blob/master/_posts/2016-07-27-rxjava-01.md))

### Preface ###
I have been spending more than half year to learn RxJava, especially how to use it on Android platform. And one of the most important reason to push me learn this knowledge is our current project which has ton thousand of code and callbacks to handle the asynchrnous staffs, and you will be very quickly lost into looking at such kind of source code. But **RxJava** is one of the technologies to save me from that hell.

### What's RxJava ###
> ReactiveX is a library for composing asynchronous and event-based programs by using observable sequences.
> 
> It extends the observer pattern to support sequences of data and/or events and adds operators that allow you to compose sequences together declaratively while abstracting away concerns about things like low-level threading, synchronization, thread-safety, concurrent data structures, and non-blocking I/O.
[More](http://reactivex.io/intro.html)

Above is the official introduction in a high level layer. But for me, its actually just one word - **Asynchronous** which is a awesome library to help implementing kinds asynchrnous operations.

### Why should I consider RxJava ###
> Reactive Programming raises the level of abstraction of your code so you can focus on the interdependence of events that define the business logic, rather than having to constantly fiddle with a large amount of implementation details. Code in RP will likely be more concise.
>
> The benefit is more evident in modern webapps and mobile apps that are highly interactive with a multitude of UI events related to data events. 10 years ago, interaction with web pages was basically about submitting a long form to the backend and performing simple rendering to the frontend. Apps have evolved to be more real-time: modifying a single form field can automatically trigger a save to the backend, "likes" to some content can be reflected in real time to other connected users, and so forth.
>
> Apps nowadays have an abundancy of real-time events of every kind that enable a highly interactive experience to the user. We need tools for properly dealing with that, and Reactive Programming is an answer. [More](https://gist.github.com/staltz/868e7e9bc2a7b8c1f754)

But to me, its also one word -
**Concision**

One of the most important key point of asynchrnouse operation is the concision. Why do I need to use AsyncTask, Handler, ThreadExecutor and all kinds of other tools to implement the same goal of synchronous? Why wouldn't I just use one technology to do all of them alignment? That's how RxJava does! 

RxJava provids a consistent and concise way to make it easy to use, and could keep concise all the time even the logic of the whole app becomes more and more complexy.

**For example**

There is a customized view called `imageCollectorView` which is used to display multiple images, and there is a method called `addImage(Bitmap)` to add any image for displaying. Assuming our app needs to load all the images under some directories `File[] folders` and display all of into `imageCollectorView`. **But** there are somethings we need to take more carefully: Reading image from local file system really costs and it has to be put into background thread instead of doing in UI Thread. And displaying image into view has to be running in UI Thread. There are lots of way to handle it, here is one of them:

```java
new Thread() {
    @Override
    public void run() {
        super.run();
        for (File folder : folders) {
            File[] files = folder.listFiles();
            for (File file : files) {
                if (file.getName().endsWith(".png")) {
                    final Bitmap bitmap = getBitmapFromFile(file);
                    getActivity().runOnUiThread(new Runnable() {
                        @Override
                        public void run() {
                            imageCollectorView.addImage(bitmap);
                        }
                    });
                }
            }
        }
    }
}.start();
```

But if we are using RxJava, here is the implementation:

```java
Observable.from(folders)
    .flatMap(new Func1<File, Observable<File>>() {
        @Override
        public Observable<File> call(File file) {
            return Observable.from(file.listFiles());
        }
    })
    .filter(new Func1<File, Boolean>() {
        @Override
        public Boolean call(File file) {
            return file.getName().endsWith(".png");
        }
    })
    .map(new Func1<File, Bitmap>() {
        @Override
        public Bitmap call(File file) {
            return getBitmapFromFile(file);
        }
    })
    .subscribeOn(Schedulers.io())
    .observeOn(AndroidSchedulers.mainThread())
    .subscribe(new Action1<Bitmap>() {
        @Override
        public void call(Bitmap bitmap) {
            imageCollectorView.addImage(bitmap);
        }
    });
```

Wait! Wait! Hold on! I know you guys will complain that: the whole code lines are obviously much more than the old one, why did you say it becomes more concise? - Okay! I got your point, but the concision I'm talking means the concision of code logic, not just the lines of code. If you are reading the code above, you will find that the implementation by RxJava is a chain execution instead of calling nesting which can help us simplify the logic, especially when your app's requirement and design becomes more complex. 

So if you asked me why should I use RxJava, I would say **Concision** which will put all the complex logic into one chain.

### How to use RxJava ###
Before we start talking how to use RxJava, I would spend some time to go through the API and philosophy of RxJava.

1. Concept: Extend of [observer pattern](http://en.wikipedia.org/wiki/Observer_pattern)
2. Basic philosophy
    
    * Create Observer
    
        Observer is the role to be responsible for listerning the event when it gets triggerred.

        ~~~ java
        Observer<String> observer = new Observer<String>() {
            @Override
            public void onNext(String s) {
                Log.d(tag, "Item: " + s);
            }
                
            @Override
            public void onCompleted() {
                Log.d(tag, "Completed!");
            }
                
            @Override
            public void onError(Throwable e) {
                Log.d(tag, "Error!");
            }
        };
        ~~~
    
        Beside *Observer*, there is another class which simplely implements `Observer`: `Subscriber`. `Subscriber` extends the API of `Observer`, but the basic functions are exactly same:
        
        ~~~ java
        Subscriber<String> subscriber = new Subscriber<String>() {
            @Override
            public void onNext(String s) {
                Log.d(tag, "Item: " + s);
            }
            
            @Override
            public void onCompleted() {
                Log.d(tag, "Completed!");
            }
            
            @Override
            public void onError(Throwable e) {
                Log.d(tag, "Error!");
            }
        };
        ~~~
